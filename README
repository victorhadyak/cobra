 cmdOutput, err := cmd.Output()
    if err != nil {
        fmt.Printf("Error listing instances in region %s: %s\n", region, err)
        return
    }

    output := strings.TrimSpace(string(cmdOutput))
    if output == "" {
        fmt.Println("No instances found in this region.")
        return
    }

    lines := strings.Split(output, "\n")
    instances := make([][2]string, 0) // To hold instance ID and Name pairs
    for _, line := range lines {
        parts := strings.Split(line, "\t")
        instanceID := parts[0]
        instanceName := "No Name Tag" // Default if no name tag is present
        if len(parts) > 1 {
            instanceName = parts[1]
        }
        instances = append(instances, [2]string{instanceID, instanceName})
        fmt.Printf("%d. %s (%s)\n", len(instances), instanceID, instanceName)
    }

    fmt.Println("Select an instance by number to connect or enter 0 to exit:")
    var selection int
    _, err = fmt.Scanln(&selection)
    if err != nil || selection < 1 || selection > len(instances) {
        fmt.Println("Invalid input, exiting.")
        return
    }

    // Use the corrected slice of instances for connection logic
    selectedInstanceID := instances[selection-1][0] // Getting the instance ID based on user selection
    fmt.Printf("Connecting to instance %s (%s) in region %s...\n", selectedInstanceID, instances[selection-1][1], region)
    // Placeholder for where you'd connect to the selected instance
    // Ensure connectInstance function or similar logic is implemented to handle the actual connection
}
